"""
V4 Step-Care Pathway Analysis Engine

Implements sequential treatment algorithms and pathway optimization.
"""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Optional

import numpy as np
import pandas as pd

from analysis.core.io import PSAData


@dataclass
class StepCarePathway:
    """Definition of a step-care treatment pathway."""
    
    name: str
    steps: List[str]  # Ordered list of therapies
    transition_probabilities: Dict[int, float]  # Probability of moving to next step
    description: Optional[str] = None


@dataclass
class StepCareResult:
    """Container for step-care pathway analysis results."""
    
    pathway_costs: pd.DataFrame          # Costs by pathway
    pathway_effects: pd.DataFrame        # Effects by pathway
    sequential_icers: pd.DataFrame       # Sequential ICERs
    frontier: pd.DataFrame               # Cost-effectiveness frontier
    pathway_probabilities: pd.DataFrame  # Probability of reaching each step


def calculate_pathway_outcomes(
    pathway: StepCarePathway,
    therapy_costs: Dict[str, float],
    therapy_effects: Dict[str, float],
    therapy_success_rates: Dict[str, float]
) -> Tuple[float, float]:
    """
    Calculate expected costs and effects for a step-care pathway.
    
    Args:
        pathway: StepCarePathway definition
        therapy_costs: Cost per patient for each therapy
        therapy_effects: Effect (QALYs) for each therapy
        therapy_success_rates: Success rate for each therapy
    
    Returns:
        Tuple of (total_cost, total_effect)
    """
    total_cost = 0.0
    total_effect = 0.0
    probability_reaching_step = 1.0
    
    for step_idx, therapy in enumerate(pathway.steps):
        # Cost of this step
        step_cost = therapy_costs.get(therapy, 0)
        total_cost += probability_reaching_step * step_cost
        
        # Effect if successful at this step
        success_rate = therapy_success_rates.get(therapy, 0.5)
        step_effect = therapy_effects.get(therapy, 0)
        total_effect += probability_reaching_step * success_rate * step_effect
        
        # Update probability of reaching next step (if treatment fails)
        if step_idx < len(pathway.steps) - 1:
            probability_reaching_step *= (1 - success_rate)
    
    return total_cost, total_effect


def run_stepcare_analysis(
    psa: PSAData,
    pathways: List[StepCarePathway],
    therapy_success_rates: Dict[str, float],
    lambda_threshold: float = 50000
) -> StepCareResult:
    """
    Run step-care pathway analysis.
    
    Args:
        psa: PSAData object
        pathways: List of step-care pathways to analyze
        therapy_success_rates: Success rate for each therapy
        lambda_threshold: WTP threshold
    
    Returns:
        StepCareResult with pathway analysis
    """
    # Get mean costs and effects
    therapy_costs = psa.table.groupby('strategy')['cost'].mean().to_dict()
    therapy_effects = psa.table.groupby('strategy')['effect'].mean().to_dict()
    
    # Calculate outcomes for each pathway
    pathway_rows = []
    
    for pathway in pathways:
        total_cost, total_effect = calculate_pathway_outcomes(
            pathway,
            therapy_costs,
            therapy_effects,
            therapy_success_rates
        )
        
        # Calculate NMB
        nmb = lambda_threshold * total_effect - total_cost
        
        pathway_rows.append({
            'pathway': pathway.name,
            'n_steps': len(pathway.steps),
            'total_cost': total_cost,
            'total_effect': total_effect,
            'nmb': nmb,
            'steps': ' â†’ '.join(pathway.steps)
        })
    
    pathway_df = pd.DataFrame(pathway_rows)
    
    # Calculate sequential ICERs
    # Sort by effect
    sorted_df = pathway_df.sort_values('total_effect').reset_index(drop=True)
    
    sequential_icer_rows = []
    
    for i in range(1, len(sorted_df)):
        prev_cost = sorted_df.loc[i-1, 'total_cost']
        prev_effect = sorted_df.loc[i-1, 'total_effect']
        curr_cost = sorted_df.loc[i, 'total_cost']
        curr_effect = sorted_df.loc[i, 'total_effect']
        
        delta_cost = curr_cost - prev_cost
        delta_effect = curr_effect - prev_effect
        
        if delta_effect > 0:
            icer = delta_cost / delta_effect
        else:
            icer = np.inf
        
        sequential_icer_rows.append({
            'pathway': sorted_df.loc[i, 'pathway'],
            'comparator': sorted_df.loc[i-1, 'pathway'],
            'delta_cost': delta_cost,
            'delta_effect': delta_effect,
            'icer': icer
        })
    
    sequential_icers = pd.DataFrame(sequential_icer_rows)
    
    # Identify frontier (non-dominated pathways)
    frontier_pathways = []
    sorted_df = sorted_df.sort_values('total_effect')
    
    for i, row in sorted_df.iterrows():
        is_dominated = False
        
        for j, other_row in sorted_df.iterrows():
            if i != j:
                # Dominated if other has lower cost and higher effect
                if (other_row['total_cost'] <= row['total_cost'] and 
                    other_row['total_effect'] >= row['total_effect']):
                    if (other_row['total_cost'] < row['total_cost'] or 
                        other_row['total_effect'] > row['total_effect']):
                        is_dominated = True
                        break
        
        if not is_dominated:
            frontier_pathways.append(row.to_dict())
    
    frontier = pd.DataFrame(frontier_pathways)
    
    # Calculate pathway probabilities (simplified)
    pathway_probs = []
    for pathway in pathways:
        prob_complete = 1.0
        for therapy in pathway.steps:
            success_rate = therapy_success_rates.get(therapy, 0.5)
            prob_complete *= success_rate
        
        pathway_probs.append({
            'pathway': pathway.name,
            'probability_complete': prob_complete,
            'probability_any_success': 1 - (1 - prob_complete)
        })
    
    pathway_probabilities = pd.DataFrame(pathway_probs)
    
    return StepCareResult(
        pathway_costs=pathway_df[['pathway', 'total_cost', 'steps']],
        pathway_effects=pathway_df[['pathway', 'total_effect', 'steps']],
        sequential_icers=sequential_icers,
        frontier=frontier,
        pathway_probabilities=pathway_probabilities
    )


def create_standard_pathways() -> List[StepCarePathway]:
    """
    Create standard step-care pathways for TRD.
    
    Returns:
        List of standard pathways
    """
    pathways = [
        StepCarePathway(
            name="Conservative",
            steps=["Usual Care", "UC+Li", "UC+AA", "rTMS"],
            transition_probabilities={0: 0.7, 1: 0.6, 2: 0.5},
            description="Conservative escalation through augmentation and rTMS"
        ),
        StepCarePathway(
            name="Psychedelic-First",
            steps=["Usual Care", "PO-KA", "KA-ECT"],
            transition_probabilities={0: 0.7, 1: 0.5},
            description="Early psychedelic intervention"
        ),
        StepCarePathway(
            name="Aggressive",
            steps=["Usual Care", "IV-KA", "ECT"],
            transition_probabilities={0: 0.7, 1: 0.6},
            description="Rapid escalation to intensive treatments"
        ),
        StepCarePathway(
            name="Comprehensive",
            steps=["Usual Care", "rTMS", "PO-KA", "IV-KA", "KA-ECT"],
            transition_probabilities={0: 0.7, 1: 0.6, 2: 0.5, 3: 0.4},
            description="Comprehensive sequential approach"
        )
    ]
    
    return pathways


def save_stepcare_results(
    stepcare_result: StepCareResult,
    output_dir: Path
) -> None:
    """
    Save step-care analysis results.
    
    Args:
        stepcare_result: Step-care results
        output_dir: Output directory
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Save pathway costs
    stepcare_result.pathway_costs.to_csv(
        output_dir / "stepcare_costs.csv", index=False
    )
    
    # Save pathway effects
    stepcare_result.pathway_effects.to_csv(
        output_dir / "stepcare_effects.csv", index=False
    )
    
    # Save sequential ICERs
    stepcare_result.sequential_icers.to_csv(
        output_dir / "stepcare_sequential_icers.csv", index=False
    )
    
    # Save frontier
    stepcare_result.frontier.to_csv(
        output_dir / "stepcare_frontier.csv", index=False
    )
    
    # Save pathway probabilities
    stepcare_result.pathway_probabilities.to_csv(
        output_dir / "stepcare_probabilities.csv", index=False
    )
